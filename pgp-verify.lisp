;;;; pgp-verify.lisp

(in-package #:pgp-verify)

(defclass packet-base ()
  ((data :type (array (unsigned-byte 8) (*))
         :initarg :data :reader packet-data)
   (body :type (array (unsigned-byte 8) (*)) :reader packet-body)
   (type :type symbol :reader packet-type)
   (length :type fixnum :reader packet-length)
   (displacement :type fixnum :reader packet-displacement
                 :initarg :displacement :initform 0))
  (:documentation "PGP packet"))

(defun make-packet (data &optional (disp 0) (class 'packet))
  (make-instance class :data (make-array (length data)
                                           :element-type '(unsigned-byte 8)
                                           :initial-contents data)
                 :displacement disp))

(defmethod initialize-instance :after ((packet packet) &key)
  (with-slots (type length body data)
      packet
    (multiple-value-bind (len len-size)
        (get-packet-length packet)
      (setf length len)
      (setf type (get-packet-type packet len-size))
      (setf body (make-array len
                             :element-type '(unsigned-byte 8)
                             :displaced-to data
                             :displaced-index-offset (1+ len-size))))))

(defclass subpacket (packet)
  ()
  (:documentation "PGP signature subpacket"))

(defgeneric get-packet-type (packet &optional len-size)
  (:documentation "Get type of the packet"))

(defun packet-sub (packet offset &optional len)
  (let ((len (or len
                 (- (array-dimension (packet-body packet) 0)
                    offset))))
    (values (make-array len
                        :element-type '(unsigned-byte 8)
                        :displaced-to (packet-body packet)
                        :displaced-index-offset offset)
            len)))

(defun packet-vector (packet offset &optional len)
  (multiple-value-bind (res off)
      (packet-sub packet offset len)
    (values (coerce res '(simple-array (unsigned-byte 8) (*)))
            off)))

(defun packet-subpacket (packet offset len &optional (class 'packet))
  (multiple-value-bind (arr disp)
      (array-displacement (packet-body packet))
    (declare (ignore arr))
    (make-packet (packet-sub packet offset len)
                 (+ (packet-displacement packet)
                    offset disp)
                 class)))

(defun packet-num-fn (data offset len)
  "Extract a big-endian number from packet"
  (let ((value 0))
    (loop for i from offset below (+ offset len)
       do (setf value (+ (ash value 8)
                         (aref data i))))
    (values value (+ offset len))))

(defmacro packet-num (data offset len)
  "Convert big-endinan encoded number to a CL number"
  (if (and (numberp len)
           (<= len 16))
      (let ((d (gensym)))
        (labels ((rec (n)
                   (if (zerop n)
                       `(aref ,d ,offset)
                       `(+ (ash ,(rec (1- n)) 8) (aref ,d (+ ,offset ,n))))))
          `(let ((,d ,data))
             (values ,(rec (1- len))
                     (+ ,offset ,len)))))
        (list 'packet-num-fn data offset len)))

(defconstant +packet-types+
  '((0 . :reserved)
    (1 . :pk-enc-session-key)
    (2 . :signature)
    (3 . :sk-enc-session-key)
    (4 . :one-pass-signature)
    (5 . :secret-key)
    (6 . :public-key)
    (7 . :secret-subkey)
    (8 . :compressed-data)
    (9 . :symm-enc-data)
    (10 . :marker)
    (11 . :literal-data)
    (12 . :trust)
    (13 . :user-id)
    (14 . :public-subkey)
    (17 . :user-attribute)
    (18 . :symm-enc-and-integrity-protected-data)
    (19 . :modification-detection-code)
    (60 . :private0)
    (61 . :private1)
    (62 . :private2)
    (63 . :private3)))

(defmethod get-packet-type ((packet packet) &optional len-size)
  (declare (ignore len-size))
  (let ((tag (packet-num (packet-data packet) 0 1)))
    (unless (= #xC0 (logand tag #xC0))
      (error "invalid packet tag format at position ~A" (packet-global-offset packet 0)))
    (let ((type (cdr (assoc (logand tag #x3F) +packet-types+))))
      (when (null type)
        (error "invalid packet type at position ~A" (packet-global-offset packet 0)))
      type)))

(defconstant +subpacket-types+
  '((0 . :reserved)
    (1 . :reserved)
    (2 . :sig-creation-time)
    (3 . :sig-expiration-time)
    (4 . :exportable-certification)
    (5 . :trust-signature)
    (6 . :regular-expression)
    (7 . :revocable)
    (8 . :reserved)
    (9 . :key-expiration-time)
    (10 . :placeholer)
    (11 . :preferred-symm-algos)
    (12 . :revocation-key)
    (13 . :reserved)
    (14 . :reserved)
    (15 . :reserved)
    (16 . :issuer)
    (17 . :reserved)
    (18 . :reserved)
    (19 . :reserved)
    (20 . :notation-data)
    (21 . :preferred-hash-algos)
    (22 . :preferred-compression-algos)
    (23 . :key-server-preferences)
    (24 . :preferred-key-server)
    (25 . :primary-user-id)
    (26 . :policy-url)
    (27 . :key-flags)
    (28 . :signers-user-id)
    (29 . :reason-for-revocation)
    (30 . :features)
    (31 . :signature-target)
    (32 . :embedded-signature)
    (100 . :private0)
    (101 . :private1)
    (102 . :private2)
    (103 . :private3)
    (104 . :private4)
    (105 . :private5)
    (106 . :private6)
    (107 . :private7)
    (108 . :private8)
    (109 . :private9)
    (110 . :private10)))

(defmethod get-packet-type ((packet subpacket) &optional len-size)
  (let ((type (packet-num (packet-data packet) len-size 1)))
    (let ((compulsory-p (plusp (logand type #x80)))
          (type (cdr (assoc (logand type #x7FF) +subpacket-types+))))
      (if (null type)
        (if compulsory-p
            (error "Not supported packet type ~D at postion ~A" type (packet-global-offset packet len-size))
            :skip)
        type))))


(defun packet-global-offset (packet off)
  (+ off (packet-displacement packet)))

(defun get-packet-length (packet)
  (let* ((data (packet-data packet))
         (1st (aref data 1)))
    (cond ((< 1st #xC0)
           (values 1st 1))
          ((< 1st #xE0)
           (values (+ #xC0 (aref data 2) (ash (- 1st #xC0) 8)) 2))
          ((= 1st #xFF)
           (values (packet-num (packet-data packet) 3 4) 5))
          (t (error "invalid packet length at position ~A"
                    (packet-global-offset packet 1))))))

(defvar *decoders* (make-hash-table))

(defmacro bind-contents (data offset new-off fields &body body)
  (once-only (data)
    (labels ((rec (f off)
               (if (null f)
                   `(progn ,@body)
                   `(multiple-value-bind (,(caar f) ,new-off)
                        ,(destructuring-bind (fn &rest args)
                                             (cadar f)
                                             `(,fn ,data ,off ,@args))
                      (declare (ignorable ,new-off))
                      ,(rec (cdr f) new-off)))))
      (rec fields offset))))

(defmacro define-decoder (type args &body body)
  (let ((name (intern (format nil "DECODE-~A" type))))
    `(progn (defun ,name ,args
              ,@body)
            (setf (gethash ,type *decoders*) #',name))))

(define-decoder :pk-enc-session-key (packet)
  (bind-contents (packet-data packet) 0 new-off
      ((version (packet-num 1))
       (key-id (packet-num 8))
       (pk-algo (packet-num 1))
       (enc-session-key (packet-vector)))
    (list :version version :key-id key-id :pk-algo pk-algo
          :enc-session-key enc-session-key)))


(define-decoder :signature (packet)
  (let ((data (packet-data packet)))
    (bind-contents data 0 off
        ((version (packet-num 1)))
      (cond ((eql version 3)
             ;; decode version 3
             (decode-version-3-signature data))
            ((eql version 4)
             (decode-version-4-signature data))
            (t (error "Invalid packet version at offset ~A" (packet-global-offset packet 0)))))))

(defun decode-version-3-signature (data)
  (bind-contents data 1 off
      ((hash-len (packet-num 1))
       (sig-type (packet-num 1))
       (creation-time (packet-num 4))
       (key-id (packet-vector 8))
       (pk-algo (packet-num 1))
       (hash-algo (packet-num 1))
       (signed-hash-16 (packet-num 2)))
    ;; TODO: Decode MPI's for RSA/DSA
    ))

(defun decode-version-4-signature (data)
  (bind-contents data 1 off
      ((sig-type (packet-num 1))
       (pk-algo (packet-num 1))
       (hash-algo (packet-num 1))
       (hashed-subpacket-length (packet-num 2)))
    (bind-contents data off off
        ((hashed-subpackets (packet-vector hashed-subpacket-length))
         (unhashed-subpacket-length (packet-num 2)))
      (bind-contents data off off
          ((unhashed-subpackets (packet-vector unhashed-subpacket-length))
           (signed-hash-16 (packet-num 2)))
        ;; TODO Decode MPI's for RSA/DSA
        ))))
